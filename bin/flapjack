#!/usr/bin/env ruby

# add lib to the default include path
unless $:.include?(File.dirname(__FILE__) + '/../lib/')
  $: << File.dirname(__FILE__) + '/../lib'
end

require 'dante'
require 'optparse'
require 'ostruct'

require 'flapjack/configuration'

options = OpenStruct.new
options.config    = File.join('etc', 'flapjack_config.yaml')
options.daemonize = nil

OptionParser.new do |opts|
  opts.banner = "Usage: flapjack COMMAND [OPTIONS]"

  opts.separator  ""
  opts.separator  "Commands"
  opts.separator  "     start #{" " * 25} start flapjack"
  opts.separator  "     stop #{" " * 26} stop flapjack"
  opts.separator  "     restart #{" " * 23} restart flapjack"
  opts.separator  ""
  opts.separator  "Options"

  opts.on("-c", "--config [PATH]", String, "PATH to the config file to use") do |c|
    options.config = c
  end

  opts.on("-d", "--[no-]daemonize", "Daemonize?") do |d|
    options.daemonize = d
  end

  opts.on("-p", "--pidfile [PATH]", String, "PATH to the pidfile to write to") do |p|
    options.pidfile = p
  end

  opts.on("-l", "--logfile [PATH]", String, "PATH to the logfile to write to") do |l|
    options.log_path = l
  end

end.parse!(ARGV)

FLAPJACK_ENV = ENV['FLAPJACK_ENV'] || 'development'

config = Flapjack::Configuration.new
config.load(options.config)
config_env = config.all

if config_env.nil? || config_env.empty?
  puts "No config data for environment '#{FLAPJACK_ENV}' found in '#{options.config}'"
  exit(false)
end

pidfile = options.pidfile.nil? ?
           (config_env['pid_file'] || 'tmp/pids/flapjack.pid') :
           options.pidfile

logfile = options.logfile.nil? ?
            (config_env['log_file'] || 'log/flapjack.log') :
            options.logfile

daemonize = options.daemonize.nil? ?
              !!config_env['daemonize'] :
              options.daemonize

require 'flapjack/coordinator'

flapjack_coord = Proc.new {
  coordinator = Flapjack::Coordinator.new(config)
  coordinator.start(:signals => true)
}

case ARGV[0]
when "start"
  print "Flapjack starting..."
  Dante::Runner.new('flapjack').execute(:daemonize => daemonize,
    :pid_path => pidfile, :log_path => logfile) {

    flapjack_coord.call
  }
  puts " done."
when "stop"
  print "Flapjack stopping..."
  Dante::Runner.new('flapjack').execute(:kill => true, :pid_path => pidfile)
  puts " done."
when "restart"
  print "Flapjack restarting..."
  Dante::Runner.new('flapjack').execute(:daemonize => true,
    :restart => true, :pid_path => pidfile, :log_path => logfile) {

    sleep 1 # get connection errors without this...
    flapjack_coord.call
  }
  puts " done."
when "status"
  runner = Dante::Runner.new('flapjack', :pid_path => pidfile, :log_path => logfile)
  uptime = (runner.daemon_running?) ? Time.now - File.stat(pidfile).ctime : 0
  if runner.daemon_running?
    puts "Flapjack is running: #{uptime}"
  else
    puts "Flapjack is not runninng"
  end
else
  if ARGV[0].empty?
    puts "No command provided"
  else
    puts "Unknown command provided: '#{ARGV[0]}'"
  end
end