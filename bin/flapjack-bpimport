#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'httparty'
require 'yajl/json_gem'
require 'redis'

# add lib to the default include path
unless $:.include?(File.dirname(__FILE__) + '/../lib/')
  $: << File.dirname(__FILE__) + '/../lib'
end

require 'flapjack/configuration'
require 'flapjack/data/contact'
require 'flapjack/data/entity'

options = OpenStruct.new
options.config = File.join('etc', 'flapjack_config.yaml')

kevlar_url = ARGV.shift

banner  = "Usage: flapjack-bpimport KEVLAR [options]\n"
banner += "\n"
banner += "  KEVLAR: root URL of a kevlar server\n"

OptionParser.new {|opts|
  opts.banner = "Usage: flapjack-bpimport URL [options]"

  opts.on("-c", "--config [PATH]", String, "PATH to the config file to use") do |c|
    options.config = c
  end

  opts.on("-u", "--username [USERNAME]", String, "USERNAME to send ") do |u|
    options.username = u
  end

  opts.on("-c", "--password [PASSWORD]", String, "PATH to the config file to use") do |p|
    options.password = p
  end

}.parse!(ARGV)

FLAPJACK_ENV = ENV['FLAPJACK_ENV'] || 'development'

config_env = Flapjack::Configuration.new.load(options.config)

module Flapjack
  module KevlarClient
    include HTTParty
    format :json

    class << self

      # TODO indicate JSON by sending content type
      def entities
        parsed( get("/services.json") )
      end

      def contacts
        parsed( get("/contacts.json") )
      end

    private

      def parsed(response)
        return unless response && response.respond_to?(:parsed_response)
        response.parsed_response
      end

    end
  end

end

def get_redis_connection(cfg)
  opts = cfg['path'] ? {:path => cfg['path']} :
                       {:host => cfg['host'], :port => cfg['port']}
  Redis.new(opts.merge(:db => cfg['db']))
end

begin
  p kevlar_url
  p options
  Flapjack::KevlarClient.base_uri(kevlar_url)
  if options.username && (options.username.length > 0) &&
     options.password && (options.password.length > 0)
    Flapjack::KevlarClient.basic_auth(options.username, options.password)
  end
  entities = Flapjack::KevlarClient.entities
  contacts = Flapjack::KevlarClient.contacts

  p entities
  p contacts

rescue Exception => e
  puts e.message
  puts e.backtrace.join("\n")
  exit(false)
end

redis = get_redis_connection(config_env['redis'])

redis.multi do |r|
  entities.each do |entity|
    unless entity['id']
      puts "Entity not imported as it has no id: " + entity.inspect
      next
    end
    Flapjack::Data::Entity.add(entity, :redis => r)
  end

  contacts.each do |contact|
    unless contact['id']
      puts "Contact not imported as it has no id: " + contact.inspect
      next
    end
    Flapjack::Data::Contact.add(contact, :redis => r)
  end
end

redis.quit