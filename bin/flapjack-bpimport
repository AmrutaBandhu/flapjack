#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'httparty'
require 'yajl/json_gem'
require 'redis'

# add lib to the default include path
unless $:.include?(File.dirname(__FILE__) + '/../lib/')
  $: << File.dirname(__FILE__) + '/../lib'
end

require 'flapjack/configuration'
require 'flapjack/data/contact'
require 'flapjack/data/entity'

options = OpenStruct.new
options.config = File.join('etc', 'flapjack_config.yaml')

kevlar_url = ARGV.shift

banner  = "Usage: flapjack-bpimport KEVLAR_URL [options]\n"
banner += "\n"
banner += "  KEVLAR_URL: root URL of a kevlar server\n"

OptionParser.new {|opts|
  opts.banner = "Usage: flapjack-bpimport KEVLAR_URL [options]"

  opts.on("-c", "--config [PATH]", String, "PATH to the config file to use") do |c|
    options.config = c
  end

  opts.on("-u", "--username [USERNAME]", String, "USERNAME of a kevlar user with an admin role") do |u|
    options.username = u
  end

  opts.on("-c", "--password [PASSWORD]", String, "PASSWORD for the kevlar user provided for USERNAME") do |p|
    options.password = p
  end

}.parse!(ARGV)

FLAPJACK_ENV = ENV['FLAPJACK_ENV'] || 'development'

config_env = Flapjack::Configuration.new.load(options.config)

module Flapjack
  module KevlarClient
    include HTTParty
    headers 'Accept' => 'application/json'
    format :json

    class << self

      def entities
        parsed( get("/services") )
      end

      def contacts
        parsed( get("/contacts") )
      end

    private

      def parsed(response)
        return unless response && response.respond_to?(:parsed_response)
        response.parsed_response
      end

    end
  end

end

def get_redis_connection(cfg)
  opts = cfg['path'] ? {:path => cfg['path']} :
                       {:host => cfg['host'], :port => cfg['port']}
  Redis.new(opts.merge(:db => cfg['db']))
end

begin
  Flapjack::KevlarClient.base_uri(kevlar_url)
  if options.username && (options.username.length > 0) &&
     options.password && (options.password.length > 0)
    Flapjack::KevlarClient.basic_auth(options.username, options.password)
  end
  entities = Flapjack::KevlarClient.entities
  contacts = Flapjack::KevlarClient.contacts
rescue Exception => e
  puts e.message
  puts e.backtrace.join("\n")
  exit(false)
end

redis = get_redis_connection(config_env['redis'])

redis.multi do

  if entities && entities.is_a?(Enumerable) && entities.any? {|e| !e['id'].nil?}
    entities.each do |entity|
      unless entity['id']
        puts "Entity not imported as it has no id: " + entity.inspect
        next
      end
      Flapjack::Data::Entity.add(entity, :redis => redis)
    end
  end

  if contacts && contacts.is_a?(Enumerable) && contacts.any? {|e| e['id']}
    contacts.each do |contact|
      unless contact['id']
        puts "Contact not imported as it has no id: " + contact.inspect
        next
      end
      Flapjack::Data::Contact.add(contact, :redis => redis)
    end
  end

end

redis.quit