#!/usr/bin/env ruby

require 'httparty'
require 'json'
require 'pp'
require 'uri'

module Flapjack

  class Diner

    include HTTParty
    format :json

    class << self

      def logger=(l)
        @logger = l
      end

      # NB: clients will need to handle any exceptions caused by,
      # e.g., network failures or non-parseable JSON data.

      def entities
        response = get("/entities")
        JSON.parse(response.body)
      end

      def checks(entity)
        entity_esc = prepare(entity, :required => 'entity')
        return if entity_esc.nil?

        response = get("/checks/#{entity_esc}")
        JSON.parse(response.body)
      end

      def status(entity)
        entity_esc = prepare(entity, :required => 'entity')
        return if entity_esc.nil?

        response = get("/status/#{entity_esc}")
        JSON.parse(response.body)
      end

      def check_status(entity, check)
        entity_esc = prepare(entity, :required => 'entity')
        check_esc = prepare(check, :required => 'check')
        return if entity_esc.nil? || check_esc.nil?

        response = get("/status/#{entity_esc}/#{check_esc}")
        JSON.parse(response.body)
      end

      def acknowledge_check!(entity, check, options = {})
        entity_esc = prepare(entity, :required => 'entity')
        check_esc = prepare(check, :required => 'check')
        return if entity_esc.nil? || check_esc.nil?

        acknowledge_check_url = "/acknowledgments/#{entity_esc}/#{check_esc}"

        if options[:summary]
          summary_esc = prepare(options[:summary])
          acknowledge_check_url += "?summary=#{summary_esc}"
        end

        response = post(acknowledge_check_url)
        JSON.parse(response.body)
      end

      def create_scheduled_maintenance!(entity, check, options = {})
        entity_esc = prepare(entity, :required => 'entity')
        check_esc = prepare(check, :required => 'check')
        start_time_esc = prepare(entity, :required => 'start time')
        duration_esc = prepare(check, :required => 'duration')
        return if entity_esc.nil? || check_esc.nil? || start_time_esc.nil? || duration_esc.nil?

        create_sch_maint_url ="/scheduled_maintenances/#{entity_esc}/#{check_esc}?" +
          "start_time=#{start_time}&duration=#{duration}"

        if options[:summary]
          summary_esc = prepare(options[:summary])
          create_sch_maint_url += "&summary=#{summary_esc}"
        end

        response = post(create_sch_maint_url)
        JSON.parse(response.body)
      end

      def scheduled_maintenances(entity, check)
        entity_esc = prepare(entity, :required => 'entity')
        check_esc = prepare(check, :required => 'check')
        return if entity_esc.nil? || check_esc.nil?

        response = get("/scheduled_maintenances/#{entity_esc}/#{check_esc}")
        JSON.parse(response.body)
      end

      def unscheduled_maintenances(entity, check)
        entity_esc = prepare(entity, :required => 'entity')
        check_esc = prepare(check, :required => 'check')
        return if entity_esc.nil? || check_esc.nil?

        response = get("/unscheduled_maintenances/#{entity_esc}/#{check_esc}")
        JSON.parse(response.body)
      end

    private

      def prepare(data, opts = [])
        if opts[:required] && data.nil?
          @logger.error "#{opts[:required].upcase} is required" if @logger
          return
        end
        URI.escape(data)
      end

    end

  end

end

Flapjack::Diner.base_uri('localhost:5081')

pp Flapjack::Diner.entities
pp Flapjack::Diner.checks('clientx-app-01')
pp Flapjack::Diner.status('clientx-app-01')
pp Flapjack::Diner.check_status('clientx-app-01', 'ping')
pp Flapjack::Diner.unscheduled_maintenances('clientx-app-01', 'ping')
pp Flapjack::Diner.scheduled_maintenances('clientx-app-01', 'ping')