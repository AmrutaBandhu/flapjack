#!/usr/bin/env ruby

FLAPJACK_ENV = ENV['FLAPJACK_ENV'] || 'development'

# require 'rubygem-s'
require 'bundler'

# subsidiary parts will require particular bundler groups as needed
Bundler.require(:default, FLAPJACK_ENV.to_sym)

# load the config hash for the current environment
config_file = File.join('etc', 'flapjack_config.yaml')

if File.file?(config_file)
  config = YAML::load(File.open(config_file))
else
  puts "Could not find 'etc/flapjack_config.yaml'"
  exit(false)
end

config_env = config[FLAPJACK_ENV]

if config_env.nil? || config_env.empty?
  puts "No config data for environment '#{FLAPJACK_ENV}'"
  exit(false)  
end

# add lib to the default include path
unless $:.include?(File.dirname(__FILE__) + '/../lib/')
  $: << File.dirname(__FILE__) + '/../lib'
end

require 'flapjack/notification/email'
require 'flapjack/notification/sms'
require 'flapjack/executive'
require 'flapjack/resqueuer'
require 'flapjack/web'

# set up initial values for all configured components
pikelets = {}

config_env.keys.each do |pikelet_type|

  # TODO, e.g.
  # 'jabber_notifier' => Flapjack::Notification::Jabber,
  # 'jabber_bot' => Flapjack::JabberBot, 
 
  case pikelet_type
  when 'executive'
    pikelets[Flapjack::Executive] = {:config => config_env[pikelet_type]}
  when 'web'
    pikelets[Flapjack::Web] = {:config => config_env[pikelet_type]}
  when 'email_notifier'
    pikelets[Flapjack::Notification::Email] = 
      {:config => config_env['email_notifier'],
       :redis_queue => 'email_notifier'}
  when 'sms_notifier'
    pikelets[Flapjack::Notification::Sms] = 
      {:config => config_env['sms_notifier'],
       :redis_queue => 'sms_notifier'}
  end 

end

# TODO Flapjack falls over when Redis restarted -- trap errors and attempt reconnect

EM.synchrony do

  def fiberise_instances(pikelet, instance_num, &block)
    instances = [1, instance_num || 1].max    
    (1..instances).each do |n|
      Fiber.new {
        block.yield
      }.resume
    end
  end

  if pikelets.include?(Flapjack::Executive)
    pikelet_opts = pikelets[Flapjack::Executive]; p pikelet_opts
    fiberise_instances(Flapjack::Executive, pikelet_opts['instances'].to_i) {
      flapjack_exec = Flapjack::Executive.new(pikelet_opts)
      flapjack_exec.main     
    }
  end

  (pikelets.keys & [Flapjack::Notification::Email, Flapjack::Notification::Sms]).each do |pikelet|
    pikelet_opts = pikelets[pikelet]; p pikelet_opts
    fiberise_instances(pikelet, pikelet_opts['instances']) {
      flapjack_rsq = Flapjack::Resqueuer.new(pikelet_opts.merge(:type => pikelet))
      flapjack_rsq.main
    }
  end

  if pikelets.include?(Flapjack::Web)
    # pikelet_opts = pikelets[Flapjack::Web]; p pikelet_opts
  
    # TODO incorporate thin config settings into flapjack config (web part)
    # there's probably a more elegant way of calling this than using a one-line
    # rackup file, too  
    ::Thin::Runner.new(["--config", "etc/thin_config.yaml", "--rackup", "coord_config.ru",
                        "--daemonize", "start"]).run!
  
  else
    # TODO daemonize using lib/flapjack/daemonizing.rb -- extracted from Thin  
  end

end
